const { getPool } = require('../database/postgres');\nconst EndDateTracker = require('../utils/end-date-tracker');\nconst winston = require('winston');\nconst cron = require('node-cron');\n\n// 복구 시스템 전용 로거\nconst recoveryLogger = winston.createLogger({\n    level: 'info',\n    format: winston.format.combine(\n        winston.format.timestamp(),\n        winston.format.json()\n    ),\n    transports: [\n        new winston.transports.File({ \n            filename: 'logs/end-date-recovery.log',\n            maxsize: 10485760, // 10MB\n            maxFiles: 5\n        }),\n        new winston.transports.Console({\n            format: winston.format.simple()\n        })\n    ]\n});\n\n/**\n * end_date 자동 복구 시스템\n */\nclass EndDateRecoveryService {\n    constructor() {\n        this.isRunning = false;\n        this.recoveryStats = {\n            totalChecks: 0,\n            inconsistenciesFound: 0,\n            successfulRecoveries: 0,\n            failedRecoveries: 0,\n            lastRun: null\n        };\n        \n        // 백업 데이터 캐시 (최근 24시간)\n        this.backupCache = new Map();\n        \n        // 복구 정책 설정\n        this.recoveryPolicy = {\n            maxRecoveryAttempts: 3,\n            recoveryTimeWindow: 24 * 60 * 60 * 1000, // 24시간\n            criticalInconsistencyThreshold: 5 * 60 * 1000, // 5분 이상 차이\n            autoRecoveryEnabled: true,\n            notifyAdminsOnRecovery: true\n        };\n        \n        this.initializeService();\n    }\n\n    /**\n     * 서비스 초기화\n     */\n    async initializeService() {\n        try {\n            await this.loadRecoveryStats();\n            await this.setupBackupSystem();\n            this.startPeriodicChecks();\n            \n            recoveryLogger.info('End date recovery service initialized', {\n                recoveryPolicy: this.recoveryPolicy,\n                stats: this.recoveryStats\n            });\n        } catch (error) {\n            recoveryLogger.error('Failed to initialize recovery service:', error);\n        }\n    }\n\n    /**\n     * 주기적 일관성 검사 시작 (10분마다)\n     */\n    startPeriodicChecks() {\n        // 10분마다 실행\n        cron.schedule('*/10 * * * *', async () => {\n            if (!this.isRunning) {\n                await this.performConsistencyCheck();\n            }\n        });\n\n        // 매일 자정에 전체 검증 및 정리\n        cron.schedule('0 0 * * *', async () => {\n            await this.performFullSystemCheck();\n            await this.cleanupOldBackups();\n        });\n\n        recoveryLogger.info('Periodic consistency checks scheduled');\n    }\n\n    /**\n     * 일관성 검사 수행\n     */\n    async performConsistencyCheck() {\n        if (this.isRunning) {\n            return { message: 'Check already in progress' };\n        }\n\n        this.isRunning = true;\n        this.recoveryStats.totalChecks++;\n        this.recoveryStats.lastRun = new Date();\n\n        try {\n            recoveryLogger.info('Starting consistency check...');\n            \n            // 1. 데이터베이스 일관성 검증\n            const inconsistencies = await this.detectInconsistencies();\n            \n            if (inconsistencies.length === 0) {\n                recoveryLogger.info('No inconsistencies found');\n                return { \n                    success: true, \n                    message: 'All end dates are consistent',\n                    inconsistencies: 0\n                };\n            }\n\n            this.recoveryStats.inconsistenciesFound += inconsistencies.length;\n            recoveryLogger.warn(`Found ${inconsistencies.length} inconsistencies`, {\n                inconsistencies: inconsistencies.map(i => ({\n                    issueId: i.issue_id,\n                    currentEndDate: i.current_end_date,\n                    expectedEndDate: i.last_recorded_end_date\n                }))\n            });\n\n            // 2. 자동 복구 시도\n            const recoveryResults = await this.attemptAutoRecovery(inconsistencies);\n            \n            // 3. 관리자 알림 (필요시)\n            if (this.recoveryPolicy.notifyAdminsOnRecovery && recoveryResults.recovered > 0) {\n                await this.notifyAdmins(recoveryResults);\n            }\n\n            return {\n                success: true,\n                inconsistencies: inconsistencies.length,\n                recovered: recoveryResults.recovered,\n                failed: recoveryResults.failed,\n                details: recoveryResults.details\n            };\n\n        } catch (error) {\n            recoveryLogger.error('Consistency check failed:', error);\n            return {\n                success: false,\n                error: error.message\n            };\n        } finally {\n            this.isRunning = false;\n        }\n    }\n\n    /**\n     * 데이터 불일치 감지\n     * @returns {Array} 불일치 항목들\n     */\n    async detectInconsistencies() {\n        const client = await pool.connect();\n        \n        try {\n            // PostgreSQL 함수를 사용하여 일관성 검증\n            const result = await client.query(`\n                SELECT * FROM validate_end_date_consistency()\n                WHERE inconsistent = true\n            `);\n\n            return result.rows;\n        } finally {\n            client.release();\n        }\n    }\n\n    /**\n     * 자동 복구 시도\n     * @param {Array} inconsistencies - 불일치 항목들\n     * @returns {Object} 복구 결과\n     */\n    async attemptAutoRecovery(inconsistencies) {\n        const results = {\n            recovered: 0,\n            failed: 0,\n            details: []\n        };\n\n        if (!this.recoveryPolicy.autoRecoveryEnabled) {\n            recoveryLogger.info('Auto recovery is disabled');\n            return results;\n        }\n\n        for (const inconsistency of inconsistencies) {\n            try {\n                const recoveryResult = await this.recoverSingleIssue(inconsistency);\n                \n                if (recoveryResult.success) {\n                    results.recovered++;\n                    this.recoveryStats.successfulRecoveries++;\n                } else {\n                    results.failed++;\n                    this.recoveryStats.failedRecoveries++;\n                }\n                \n                results.details.push({\n                    issueId: inconsistency.issue_id,\n                    success: recoveryResult.success,\n                    method: recoveryResult.method,\n                    message: recoveryResult.message\n                });\n\n            } catch (error) {\n                results.failed++;\n                this.recoveryStats.failedRecoveries++;\n                results.details.push({\n                    issueId: inconsistency.issue_id,\n                    success: false,\n                    error: error.message\n                });\n            }\n        }\n\n        recoveryLogger.info('Auto recovery completed', results);\n        return results;\n    }\n\n    /**\n     * 단일 이슈 복구\n     * @param {Object} inconsistency - 불일치 정보\n     * @returns {Object} 복구 결과\n     */\n    async recoverSingleIssue(inconsistency) {\n        const client = await pool.connect();\n        \n        try {\n            const issueId = inconsistency.issue_id;\n            const currentEndDate = inconsistency.current_end_date;\n            const lastRecordedEndDate = inconsistency.last_recorded_end_date;\n            \n            // 1. 백업 데이터에서 올바른 값 찾기\n            const correctEndDate = await this.findCorrectEndDate(issueId, client);\n            \n            if (!correctEndDate) {\n                return {\n                    success: false,\n                    method: 'backup_lookup',\n                    message: 'No reliable backup data found'\n                };\n            }\n\n            // 2. 복구 정책에 따른 검증\n            const timeDifference = Math.abs(\n                new Date(currentEndDate) - new Date(correctEndDate.value)\n            );\n            \n            if (timeDifference < this.recoveryPolicy.criticalInconsistencyThreshold) {\n                return {\n                    success: false,\n                    method: 'policy_check',\n                    message: 'Inconsistency below critical threshold'\n                };\n            }\n\n            // 3. 세션 컨텍스트 설정\n            await EndDateTracker.setSessionContext(client, {\n                currentUser: 'RECOVERY_SYSTEM',\n                changeType: 'AUTOMATIC_RECOVERY',\n                changeReason: `Automatic recovery: fixed inconsistency (${correctEndDate.method})`,\n                clientIp: 'system',\n                userAgent: 'EndDateRecoveryService'\n            });\n\n            // 4. 데이터 복구 실행\n            await client.query(`\n                UPDATE issues \n                SET end_date = $1 \n                WHERE id = $2\n            `, [correctEndDate.value, issueId]);\n\n            recoveryLogger.info('Issue end_date recovered', {\n                issueId,\n                oldEndDate: currentEndDate,\n                newEndDate: correctEndDate.value,\n                method: correctEndDate.method,\n                timeDifference\n            });\n\n            return {\n                success: true,\n                method: correctEndDate.method,\n                message: `End date recovered using ${correctEndDate.method}`,\n                oldValue: currentEndDate,\n                newValue: correctEndDate.value\n            };\n\n        } finally {\n            client.release();\n        }\n    }\n\n    /**\n     * 올바른 end_date 값 찾기\n     * @param {number} issueId - 이슈 ID\n     * @param {Object} client - DB 클라이언트\n     * @returns {Object|null} 올바른 값과 방법\n     */\n    async findCorrectEndDate(issueId, client) {\n        // 1. 감사 로그에서 가장 최근의 신뢰할 수 있는 값 찾기\n        const auditResult = await client.query(`\n            SELECT new_end_date, changed_by, change_type, created_at\n            FROM end_date_audit_log\n            WHERE issue_id = $1\n            AND change_type NOT IN ('BLOCKED', 'AUTOMATIC_RECOVERY')\n            AND new_end_date IS NOT NULL\n            AND suspicious_pattern = false\n            ORDER BY created_at DESC\n            LIMIT 3\n        `, [issueId]);\n\n        if (auditResult.rows.length > 0) {\n            // 최근 3개 기록 중 가장 일관된 값 선택\n            const recentChanges = auditResult.rows;\n            const valueFrequency = new Map();\n            \n            recentChanges.forEach(change => {\n                const value = change.new_end_date.toISOString();\n                valueFrequency.set(value, (valueFrequency.get(value) || 0) + 1);\n            });\n            \n            // 가장 빈번한 값 선택\n            const mostFrequentValue = Array.from(valueFrequency.entries())\n                .sort((a, b) => b[1] - a[1])[0];\n            \n            if (mostFrequentValue) {\n                return {\n                    value: mostFrequentValue[0],\n                    method: 'audit_log_consensus',\n                    confidence: mostFrequentValue[1] / recentChanges.length\n                };\n            }\n        }\n\n        // 2. 백업 캐시에서 찾기\n        const backupData = this.backupCache.get(issueId);\n        if (backupData && this.isBackupDataValid(backupData)) {\n            return {\n                value: backupData.endDate,\n                method: 'backup_cache',\n                confidence: backupData.confidence\n            };\n        }\n\n        // 3. 이슈 생성 시점의 원본 값으로 복원 (마지막 수단)\n        const originalResult = await client.query(`\n            SELECT new_end_date\n            FROM end_date_audit_log\n            WHERE issue_id = $1\n            AND change_type = 'INSERT'\n            ORDER BY created_at ASC\n            LIMIT 1\n        `, [issueId]);\n\n        if (originalResult.rows.length > 0) {\n            return {\n                value: originalResult.rows[0].new_end_date,\n                method: 'original_creation_value',\n                confidence: 0.7\n            };\n        }\n\n        return null;\n    }\n\n    /**\n     * 백업 데이터 유효성 검증\n     * @param {Object} backupData - 백업 데이터\n     * @returns {boolean} 유효성\n     */\n    isBackupDataValid(backupData) {\n        const now = Date.now();\n        const backupAge = now - backupData.timestamp;\n        \n        // 24시간 이내이고 신뢰도가 0.8 이상\n        return backupAge < this.recoveryPolicy.recoveryTimeWindow && \n               backupData.confidence >= 0.8;\n    }\n\n    /**\n     * 백업 시스템 설정\n     */\n    async setupBackupSystem() {\n        // 30분마다 현재 상태를 백업\n        cron.schedule('*/30 * * * *', async () => {\n            await this.createBackupSnapshot();\n        });\n\n        recoveryLogger.info('Backup system initialized');\n    }\n\n    /**\n     * 현재 상태 백업 스냅샷 생성\n     */\n    async createBackupSnapshot() {\n        try {\n            const client = await pool.connect();\n            \n            const result = await client.query(`\n                SELECT id, end_date, updated_at\n                FROM issues\n                WHERE status = 'active'\n                ORDER BY updated_at DESC\n                LIMIT 100\n            `);\n\n            const timestamp = Date.now();\n            \n            for (const issue of result.rows) {\n                this.backupCache.set(issue.id, {\n                    endDate: issue.end_date,\n                    timestamp,\n                    confidence: 1.0,\n                    source: 'periodic_backup'\n                });\n            }\n\n            client.release();\n            recoveryLogger.debug(`Backup snapshot created for ${result.rows.length} issues`);\n            \n        } catch (error) {\n            recoveryLogger.error('Failed to create backup snapshot:', error);\n        }\n    }\n\n    /**\n     * 오래된 백업 정리\n     */\n    async cleanupOldBackups() {\n        const cutoffTime = Date.now() - this.recoveryPolicy.recoveryTimeWindow;\n        let cleanedCount = 0;\n        \n        for (const [issueId, backupData] of this.backupCache.entries()) {\n            if (backupData.timestamp < cutoffTime) {\n                this.backupCache.delete(issueId);\n                cleanedCount++;\n            }\n        }\n\n        recoveryLogger.info(`Cleaned up ${cleanedCount} old backup entries`);\n    }\n\n    /**\n     * 전체 시스템 검증\n     */\n    async performFullSystemCheck() {\n        recoveryLogger.info('Starting full system check...');\n        \n        try {\n            // 1. 일관성 검사\n            const consistencyResult = await EndDateTracker.validateAndRepairConsistency();\n            \n            // 2. 감사 로그 무결성 검증\n            const auditIntegrity = await this.validateAuditLogIntegrity();\n            \n            // 3. 성능 지표 수집\n            const performanceMetrics = await this.collectPerformanceMetrics();\n            \n            const fullCheckResult = {\n                timestamp: new Date(),\n                consistency: consistencyResult,\n                auditIntegrity,\n                performance: performanceMetrics,\n                recoveryStats: this.recoveryStats\n            };\n\n            recoveryLogger.info('Full system check completed', fullCheckResult);\n            return fullCheckResult;\n            \n        } catch (error) {\n            recoveryLogger.error('Full system check failed:', error);\n            throw error;\n        }\n    }\n\n    /**\n     * 감사 로그 무결성 검증\n     */\n    async validateAuditLogIntegrity() {\n        const client = await pool.connect();\n        \n        try {\n            // 1. 중복 항목 검사\n            const duplicatesResult = await client.query(`\n                SELECT issue_id, old_end_date, new_end_date, created_at, COUNT(*)\n                FROM end_date_audit_log\n                GROUP BY issue_id, old_end_date, new_end_date, created_at\n                HAVING COUNT(*) > 1\n            `);\n\n            // 2. 의심스러운 패턴 통계\n            const suspiciousResult = await client.query(`\n                SELECT COUNT(*) as suspicious_count\n                FROM end_date_audit_log\n                WHERE suspicious_pattern = true\n                AND created_at > NOW() - INTERVAL '24 hours'\n            `);\n\n            // 3. 빈번한 변경자 확인\n            const frequentChangersResult = await client.query(`\n                SELECT changed_by, COUNT(*) as change_count\n                FROM end_date_audit_log\n                WHERE created_at > NOW() - INTERVAL '24 hours'\n                GROUP BY changed_by\n                HAVING COUNT(*) > 10\n                ORDER BY change_count DESC\n            `);\n\n            return {\n                duplicates: duplicatesResult.rows.length,\n                suspiciousPatterns: parseInt(suspiciousResult.rows[0].suspicious_count),\n                frequentChangers: frequentChangersResult.rows\n            };\n            \n        } finally {\n            client.release();\n        }\n    }\n\n    /**\n     * 성능 지표 수집\n     */\n    async collectPerformanceMetrics() {\n        const client = await pool.connect();\n        \n        try {\n            const metricsResult = await client.query(`\n                SELECT \n                    COUNT(*) as total_issues,\n                    COUNT(*) FILTER (WHERE status = 'active') as active_issues,\n                    AVG(EXTRACT(EPOCH FROM (end_date - created_at))) as avg_duration_seconds,\n                    COUNT(*) FILTER (WHERE end_date < NOW()) as expired_issues\n                FROM issues\n            `);\n\n            const auditStatsResult = await client.query(`\n                SELECT \n                    COUNT(*) as total_audit_entries,\n                    COUNT(DISTINCT issue_id) as tracked_issues,\n                    COUNT(*) FILTER (WHERE created_at > NOW() - INTERVAL '24 hours') as recent_changes\n                FROM end_date_audit_log\n            `);\n\n            return {\n                issues: metricsResult.rows[0],\n                audit: auditStatsResult.rows[0],\n                backupCacheSize: this.backupCache.size\n            };\n            \n        } finally {\n            client.release();\n        }\n    }\n\n    /**\n     * 관리자에게 복구 결과 알림\n     * @param {Object} results - 복구 결과\n     */\n    async notifyAdmins(results) {\n        try {\n            const client = await pool.connect();\n            \n            const message = `자동 복구 시스템이 ${results.recovered}개의 마감시간 불일치를 수정했습니다. ` +\n                          `실패: ${results.failed}건. 상세 내역을 확인해주세요.`;\n            \n            await client.query(`\n                INSERT INTO notifications (user_id, title, message, type, priority, data, created_at)\n                SELECT \n                    u.id,\n                    '마감시간 자동 복구 완료',\n                    $1,\n                    'system_recovery',\n                    'medium',\n                    $2,\n                    NOW()\n                FROM users u\n                WHERE u.role = 'admin'\n            `, [message, JSON.stringify(results)]);\n            \n            client.release();\n            recoveryLogger.info('Admin notification sent for recovery results');\n            \n        } catch (error) {\n            recoveryLogger.error('Failed to notify admins:', error);\n        }\n    }\n\n    /**\n     * 복구 통계 로드\n     */\n    async loadRecoveryStats() {\n        // 실제 구현에서는 데이터베이스나 파일에서 통계 로드\n        // 여기서는 기본값 사용\n        recoveryLogger.info('Recovery stats loaded', this.recoveryStats);\n    }\n\n    /**\n     * 서비스 상태 조회\n     */\n    getServiceStatus() {\n        return {\n            isRunning: this.isRunning,\n            stats: this.recoveryStats,\n            policy: this.recoveryPolicy,\n            backupCacheSize: this.backupCache.size,\n            nextCheck: 'Every 10 minutes',\n            nextFullCheck: 'Daily at midnight'\n        };\n    }\n\n    /**\n     * 정책 업데이트\n     * @param {Object} newPolicy - 새로운 정책\n     */\n    updateRecoveryPolicy(newPolicy) {\n        this.recoveryPolicy = { ...this.recoveryPolicy, ...newPolicy };\n        recoveryLogger.info('Recovery policy updated', this.recoveryPolicy);\n    }\n}\n\n// 전역 인스턴스 생성\nconst recoveryService = new EndDateRecoveryService();\n\nmodule.exports = {\n    EndDateRecoveryService,\n    recoveryService\n};